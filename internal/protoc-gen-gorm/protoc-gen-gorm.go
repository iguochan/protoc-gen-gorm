package protoc_gen_gorm

import (
	"fmt"
	"strconv"
	"strings"
	"unicode"

	"github.com/IguoChan/protoc-gen-gorm/option"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	timePackage    = protogen.GoImportPath("time")
	jsonPackage    = protogen.GoImportPath("encoding/json")
	reflectPackage = protogen.GoImportPath("reflect")
	fmtPackage     = protogen.GoImportPath("fmt")
	driverPackage  = protogen.GoImportPath("database/sql/driver")

	gormPackage      = protogen.GoImportPath("gorm.io/gorm")
	dateTypesPackage = protogen.GoImportPath("gorm.io/datatypes")
	mysqlxPackage    = protogen.GoImportPath("github.com/IguoChan/go-pkg/mysqlx")
	ptypesPackage    = protogen.GoImportPath("github.com/golang/protobuf/ptypes")

	structSuffix                   = "Model"
	timestampImportGoIndent        = "timestamp.Timestamp"
	timestampImportGoIndentPointer = "*timestamp.Timestamp"
	timestampImportProto           = "google/protobuf/timestamp.proto"
)

var (
	specialMessageKinds = map[string]struct{}{
		timestampImportGoIndent:        {},
		timestampImportGoIndentPointer: {},
	}
)

type GormGenerator struct {
	gen                *protogen.Plugin
	file               *protogen.File
	g                  *protogen.GeneratedFile
	version            string
	maybeIgnoreGoTypes map[string]struct{}
	//m    *Message // 当时正在处理的message
}

func New(gen *protogen.Plugin, file *protogen.File, ver string) *GormGenerator {
	return &GormGenerator{
		gen:                gen,
		file:               file,
		maybeIgnoreGoTypes: make(map[string]struct{}),
	}
}

type Message struct {
	*protogen.Message
	hasPriKeyField  bool
	hasDeletedField bool
	parent          *Message
	changeGoTypes   map[string]goIdent
	pb2ModelGoTypes map[string]string
	model2PbGoTypes map[string]string
	//columns        map[string]struct{}
}

type goIdent struct {
	field     *protogen.Field
	oldGoType string
	newGoType string
	needNew   bool
}

func (gg *GormGenerator) GenerateFile() *protogen.GeneratedFile {
	if len(gg.file.Messages) == 0 || !existExtension(gg.file.Messages) {
		return nil
	}

	filename := gg.file.GeneratedFilenamePrefix + ".gorm.pb.go"
	gg.g = gg.gen.NewGeneratedFile(filename, gg.file.GoImportPath)
	gg.g.P("// Code generated by protoc-gen-gorm. DO NOT EDIT.")
	gg.g.P("// versions:")
	gg.g.P("// - protoc-gen-gorm v", gg.version)
	gg.g.P("// - protoc          ", gg.protocVersion())
	if gg.file.Proto.GetOptions().GetDeprecated() {
		gg.g.P("// ", gg.file.Desc.Path(), " is a deprecated gg.file.")
	} else {
		gg.g.P("// source: ", gg.file.Desc.Path())
	}
	gg.g.P()

	gg.g.P("package ", gg.file.GoPackageName)
	gg.g.P()

	for _, m := range gg.file.Messages {
		gg.genMessage(&Message{
			Message: m,
			//columns: make(map[string]struct{}),
			changeGoTypes:   make(map[string]goIdent),
			pb2ModelGoTypes: make(map[string]string),
			model2PbGoTypes: make(map[string]string),
		})
		gg.g.P()
	}

	return gg.g
}

func existExtension(msgs []*protogen.Message) bool {
	for _, m := range msgs {
		if proto.HasExtension(m.Desc.Options(), option.E_SetTable) {
			return true
		}
	}

	return false
}

func setGorm(m *Message) bool {
	if m == nil {
		return false
	}

	if proto.HasExtension(m.Desc.Options(), option.E_SetTable) {
		return true
	}

	return setGorm(m.parent)
}

func hasPrimaryKey(m *Message) bool {
	if m == nil {
		return false
	}

	if m.hasPriKeyField {
		return true
	}

	return hasPrimaryKey(m.parent)
}

func setPrimaryKey(m *Message) {
	if m == nil {
		return
	}
	m.hasPriKeyField = true
	setPrimaryKey(m.parent)
}

func hasDeletedField(m *Message) bool {
	if m == nil {
		return false
	}
	if m.hasDeletedField {
		return true
	}
	return hasDeletedField(m.parent)
}

func setDeletedField(m *Message) {
	if m == nil {
		return
	}
	m.hasDeletedField = true
	setDeletedField(m.parent)
}

func (gg *GormGenerator) genMessage(m *Message) {
	if m.Desc.IsMapEntry() {
		return
	}

	for _, pm := range m.Messages {
		subM := &Message{
			Message:         pm,
			parent:          m,
			changeGoTypes:   make(map[string]goIdent),
			pb2ModelGoTypes: make(map[string]string),
			model2PbGoTypes: make(map[string]string),
		}
		gg.genMessage(subM)
	}

	if !setGorm(m) {
		return
	}

	gg.g.P("// GormModel is an option for ", m.GoIdent)
	gg.g.P("type ", m.GoIdent, structSuffix, " struct {")
	gg.genMessageFields(m)
	gg.g.P("}")
	gg.g.P()

	if proto.HasExtension(m.Desc.Options(), option.E_SetTable) && !setGorm(m.parent) {
		gg.genTableNameMethod(m)
	}

	gg.genNewType(m)
	gg.genModel2PbMethod(m)
	gg.genPb2ModelMethod(m)

	gg.genIndexOptionFunction(m)
	gg.genMaybeIgnoreGoTypes()
}

func (gg *GormGenerator) genMessageFields(m *Message) {
	for _, field := range m.Fields {
		gg.genMessageField(m, field)
	}
}

type structTags [][2]string

func (tags structTags) String() string {
	if len(tags) == 0 {
		return ""
	}
	var ss []string
	for _, tag := range tags {
		// NOTE: When quoting the value, we need to make sure the backtick
		// character does not appear. Convert all cases to the escaped hex form.
		key := tag[0]
		val := strings.Replace(strconv.Quote(tag[1]), "`", `\x60`, -1)
		ss = append(ss, fmt.Sprintf("%s:%s", key, val))
	}
	return "`" + strings.Join(ss, " ") + "`"
}

func (gg *GormGenerator) genMessageField(m *Message, field *protogen.Field) {
	goType, pointer := gg.fieldGoType(field)
	if pointer {
		goType = "*" + goType
	}
	tags := structTags{
		{"gorm", gg.fieldGormTagValue(m, field)},
		{"json", gg.fieldJSONTagValue(field)},
	}

	goType = gg.changeGoType(m, field, goType)

	name := field.GoName
	gg.g.P(name, " ", goType, tags)
}

func (gg *GormGenerator) changeGoType(m *Message, field *protogen.Field, goType string) string {
	newGoType := goType
	if v := proto.GetExtension(field.Desc.Options(), option.E_Rules); v != nil {
		rules, ok := v.(*option.Rules)
		if ok && rules.GetType() != nil {
			if rules.GetType() != nil {
				switch r := rules.Type.(type) {
				case *option.Rules_Time:
					if t := r.Time.Type; t != nil {
						if _, ok := specialMessageKinds[goType]; ok {
							gg.maybeIgnoreGoTypes[goType] = struct{}{}
						}
						newGoType = gg.g.QualifiedGoIdent(timePackage.Ident("Time"))
						if *t == option.TimeType_date {
							newGoType = gg.g.QualifiedGoIdent(dateTypesPackage.Ident("Date"))
						} else if r.Time.GetDeletedAt() {
							newGoType = gg.g.QualifiedGoIdent(gormPackage.Ident("DeletedAt"))
						}
					}
				case *option.Rules_Enum:
					if t := r.Enum.Type; t != nil {
						switch *t {
						case option.EnumType_enum, option.EnumType_string:
							newGoType = "string"
						}
					}
				}
			}
		}
	}

	switch field.Desc.Kind() {
	case protoreflect.MessageKind, protoreflect.GroupKind:
		if _, ok := specialMessageKinds[goType]; !ok {
			newGoType += structSuffix
		}
	}

	if newGoType != goType {
		m.changeGoTypes[field.GoName] = goIdent{
			field:     field,
			oldGoType: goType,
			newGoType: newGoType,
		}
	}

	if field.Desc.IsList() {
		newGoType = m.GoIdent.GoName + structSuffix + field.GoName + "List"
		m.changeGoTypes[field.GoName] = goIdent{
			field:     field,
			oldGoType: goType,
			newGoType: newGoType,
			needNew:   true,
		}
	}
	if field.Desc.IsMap() {
		newGoType = m.GoIdent.GoName + structSuffix + field.GoName + "Map"
		m.changeGoTypes[field.GoName] = goIdent{
			field:     field,
			oldGoType: goType,
			newGoType: newGoType,
			needNew:   true,
		}
	}

	return newGoType
}

func (gg *GormGenerator) fieldJSONTagValue(field *protogen.Field) string {
	return string(field.Desc.Name()) + ",omitempty"
}

//func checkColumnUnique(m *Message, column string) bool {
//	_, ok := m.columns[column]
//	return !ok
//}
//
//func setColumn(m *Message, column string) {
//	m.columns[column] = struct{}{}
//}

func (gg *GormGenerator) fieldGormTagValue(m *Message, field *protogen.Field) string {
	if proto.HasExtension(field.Desc.Options(), option.E_IgnoreGormColumn) {
		return "-"
	}

	column := camelToSnake(string(field.Desc.Name()))
	//if !checkColumnUnique(m, column) {
	//	panic(fmt.Sprintf("column %s is not unique", column))
	//}
	//setColumn(m, column)

	switch field.Desc.Kind() {
	case protoreflect.MessageKind, protoreflect.GroupKind:
		if gg.g.QualifiedGoIdent(field.Message.GoIdent) != timestampImportGoIndent && !field.Desc.IsMap() {
			return "embedded;embeddedPrefix:" + column + "_"
		}
	}

	tag := "column:" + column
	v := proto.GetExtension(field.Desc.Options(), option.E_Rules)
	if v == nil {
		return tag
	}
	rules, ok := v.(*option.Rules)
	if !ok {
		return tag
	}

	if rules.GetColumnName() != "" {
		tag = "column:" + rules.GetColumnName()
	}

	if rules.GetType() != nil {
		switch r := rules.Type.(type) {
		case *option.Rules_Bool:
			if field.Desc.Kind() != protoreflect.BoolKind {
				panic(fmt.Sprintf("field %s is not bool", field.GoName))
			}
			tag += ";type:bool"
			if r.Bool.Default != nil {
				tag += ";default:" + strconv.FormatBool(r.Bool.GetDefault())
			}
		case *option.Rules_Int:
			unsigned, b64 := false, false
			switch field.Desc.Kind() {
			case protoreflect.Int32Kind,
				protoreflect.Sfixed32Kind:
			case protoreflect.Int64Kind,
				protoreflect.Sfixed64Kind:
				b64 = true
			case protoreflect.Uint32Kind,
				protoreflect.Fixed32Kind:
				unsigned = true
			case protoreflect.Uint64Kind,
				protoreflect.Fixed64Kind:
				unsigned, b64 = true, true
			default:
				panic(fmt.Sprintf("field %s is not interger", field.GoName))
			}
			_ = b64

			if _, ok := option.IntType_name[int32(r.Int.GetType())]; !ok && r.Int.Type != nil {
				panic(fmt.Sprintf("field %s type %s is not support", field.GoName, r.Int.GetType().String()))
			}

			if s := r.Int.GetSize(); s > 0 {
				tag += fmt.Sprintf(";size:%d", s)
			}
			if t := r.Int.Type; t != nil { // 没有设置size的情况下我们再根据type设置
				tag += fmt.Sprintf(";type:%s", t.String())

				if w := r.Int.GetWidth(); w != 0 {
					tag += fmt.Sprintf("(%d)", w)
				}
				if unsigned {
					tag += " unsigned"
				}

			}

			if r.Int.Default != nil {
				tag += fmt.Sprintf(";default:%d", r.Int.GetDefault())
			}
		case *option.Rules_Float:
			switch field.Desc.Kind() {
			case protoreflect.FloatKind:
			case protoreflect.DoubleKind:
			default:
				panic(fmt.Sprintf("field %s is not interger", field.GoName))
			}

			if _, ok := option.FloatType_name[int32(r.Float.GetType())]; !ok && r.Float.Type != nil {
				panic(fmt.Sprintf("field %s type %s is not support", field.GoName, r.Float.GetType().String()))
			}

			if t := r.Float.Type; t != nil {
				tag += fmt.Sprintf(";type:%s", t.String())
				if precision := r.Float.GetPrecision(); precision != nil {
					if precision.GetM() < precision.GetD() {
						panic(fmt.Sprintf("field %s precision is invalid, m:%d must bigger than d:%d", field.GoName, precision.GetM(), precision.GetD()))
					}
					tag += fmt.Sprintf("(%d,%d)", precision.GetM(), precision.GetD())
				}
				if u := r.Float.Unsigned; u != nil && *u {
					tag += " unsigned"
				}
			}

			if r.Float.Default != nil {
				tag += fmt.Sprintf(";default:%f", r.Float.GetDefault())
			}

		case *option.Rules_Time:
			switch field.Desc.Kind() {
			case protoreflect.Int64Kind, protoreflect.Uint64Kind, protoreflect.StringKind:
			//  支持使用int64/uint64/string来描述时间
			case protoreflect.MessageKind, protoreflect.GroupKind:
				if gg.g.QualifiedGoIdent(field.Message.GoIdent) != timestampImportGoIndent || gg.gen.FilesByPath[timestampImportProto] == nil {
					panic(fmt.Sprintf("field %s is not support time", field.GoName))
				}
			default:
				panic(fmt.Sprintf("field %s is not support time", field.GoName))
			}

			if _, ok := option.TimeType_name[int32(r.Time.GetType())]; !ok && r.Time.Type != nil {
				panic(fmt.Sprintf("field %s type %s is not support", field.GoName, r.Time.GetType().String()))
			}

			if t := r.Time.Type; t != nil {
				tag += fmt.Sprintf(";type:%s", t.String())
				if r.Time.GetAutoCreateTime() {
					tag += ";autoCreateTime"
					switch r.Time.GetTimeUnit() {
					case option.TimeUnit_ms:
						tag += ":milli"
					case option.TimeUnit_ns:
						tag += ":nano"
					}
				}
				if r.Time.GetAutoUpdateTime() {
					tag += ";autoUpdateTime"
				}
				if r.Time.GetDeletedAt() {
					if hasDeletedField(m) {
						panic(fmt.Sprintf("message %s has more than one deleted field", m.GoIdent.GoName))
					}
					if rules.GetNotNull() { // 删除时间资源不能为非空
						*rules.NotNull = false
					}
					tag += fmt.Sprintf(";index:idx_%s", camelToSnake(field.GoName))
					setDeletedField(m)
				}
			}

		case *option.Rules_Binary:
			switch field.Desc.Kind() {
			case protoreflect.BytesKind:
			default:
				panic(fmt.Sprintf("field %s is not support binary", field.GoName))
			}

			if _, ok := option.BinaryType_name[int32(r.Binary.GetType())]; !ok && r.Binary.Type != nil {
				panic(fmt.Sprintf("field %s type %s is not support", field.GoName, r.Binary.GetType().String()))
			}

			if t := r.Binary.Type; t != nil {
				tag += fmt.Sprintf(";type:%s", t.String())
				switch *t {
				case option.BinaryType_binary:
					if r.Binary.GetBinaryWidth() > 0 {
						tag += fmt.Sprintf("(%d)", r.Binary.GetBinaryWidth())
					}
				case option.BinaryType_varbinary:
					w := uint32(256)
					if r.Binary.GetBinaryWidth() > 0 {
						w = r.Binary.GetBinaryWidth()
					}
					tag += fmt.Sprintf("(%d)", w)
				}
			}
			if r.Binary.GetSize() > 0 {
				tag += fmt.Sprintf(";size:%d", r.Binary.GetSize())
			}
			if r.Binary.Default != nil {
				bs := r.Binary.GetDefault()
				tag += fmt.Sprintf(";default:'%s'", string(bs))
			}

		case *option.Rules_String_:
			switch field.Desc.Kind() {
			case protoreflect.StringKind:
			default:
				panic(fmt.Sprintf("field %s is not support string", field.GoName))
			}

			if _, ok := option.StringType_name[int32(r.String_.GetType())]; !ok && r.String_.Type != nil {
				panic(fmt.Sprintf("field %s type %s is not support", field.GoName, r.String_.GetType().String()))
			}

			if t := r.String_.Type; t != nil {
				tag += fmt.Sprintf(";type:%s", t.String())
				switch *t {
				case option.StringType_char:
					if r.String_.GetCharWidth() > 0 {
						tag += fmt.Sprintf("(%d)", r.String_.GetCharWidth())
					}
				case option.StringType_varchar:
					w := uint32(256)
					if r.String_.GetCharWidth() > 0 {
						w = r.String_.GetCharWidth()
					}
					tag += fmt.Sprintf("(%d)", w)
				}
			}
			if r.String_.GetSize() > 0 {
				tag += fmt.Sprintf(";size:%d", r.String_.GetSize())
			}
			if r.String_.Default != nil {
				bs := r.String_.GetDefault()
				tag += fmt.Sprintf(";default:'%s'", string(bs))
			}

		case *option.Rules_Enum:
			switch field.Desc.Kind() {
			case protoreflect.EnumKind:
			default:
				panic(fmt.Sprintf("field %s is not support enum", field.GoName))
			}

			if _, ok := option.EnumType_name[int32(r.Enum.GetType())]; !ok && r.Enum.Type != nil {
				panic(fmt.Sprintf("field %s type %s is not support", field.GoName, r.Enum.GetType().String()))
			}

			if t := r.Enum.Type; t != nil {
				switch *t {
				case option.EnumType_enum:
					tag += fmt.Sprintf(";type:%s", t.String())
					if len(r.Enum.GetEnumValues()) == 0 {
						panic(fmt.Sprintf("field %s enum values is empty", field.GoName))
					}

					if r.Enum.EnumValues != nil {
						values := r.Enum.GetEnumValues()
						enums := strings.Join(values, "','")
						tag += fmt.Sprintf("('%s')", enums)
					}

					fallthrough
				case option.EnumType_string:
					if r.Enum.GetDefault() != nil {
						switch r.Enum.Default.(type) {
						case *option.EnumRules_StringDefault:
							tag += fmt.Sprintf(";default:'%s'", r.Enum.Default.(*option.EnumRules_StringDefault).StringDefault)
						default:
							panic(fmt.Sprintf("field %s enum default is not support", field.GoName))
						}
					}
				case option.EnumType_int32:
					tag += fmt.Sprintf(";type:%s", "int")
					if r.Enum.GetDefault() != nil {
						switch r.Enum.Default.(type) {
						case *option.EnumRules_IntDefault:
							tag += fmt.Sprintf(";default:%d", r.Enum.Default.(*option.EnumRules_IntDefault).IntDefault)
						default:
							panic(fmt.Sprintf("field %s enum default is not support", field.GoName))
						}
					}
				}
			}
		}
	}

	if rules.GetIdx() != nil {
		switch r := rules.Idx.(type) {
		case *option.Rules_PrimaryKey:
			if r.PrimaryKey {
				if hasPrimaryKey(m) {
					panic(fmt.Sprintf("message %s has multi primary key", m.GoIdent))
				}
				tag += ";primaryKey"
				setPrimaryKey(m)
			}
		case *option.Rules_UniqueIndex:
			if i := r.UniqueIndex; i != nil {
				tag += fmt.Sprintf(";uniqueIndex:%s,priority:%d", i.GetName(), i.GetPriority())
			}
		case *option.Rules_Index:
			if i := r.Index; i != nil {
				tag += fmt.Sprintf(";index:%s", i.GetName())
				if i.GetPriority() > 0 {
					tag += fmt.Sprintf(",priority:%d", i.GetPriority())
				}
				if i.GetUnique() {
					tag += ",unique"
				}
			}
		}
	}

	if rules.GetNotNull() {
		tag += ";not null"
	}

	if field.Desc.IsList() || field.Desc.IsMap() {
		tag += ";type:longtext"
	}

	return tag
}

func (gg *GormGenerator) genTableNameMethod(m *Message) {
	gg.g.P("func (x *", m.GoIdent, structSuffix, ") TableName() string {")
	tableName := camelToSnake(m.GoIdent.GoName)
	if proto.HasExtension(m.Desc.Options(), option.E_TableName) {
		tableName = proto.GetExtension(m.Desc.Options(), option.E_TableName).(string)
	}
	gg.g.P("return \"", tableName, "\"")
	gg.g.P("}")
	gg.g.P()
}

func (gg *GormGenerator) genPb2ModelMethod(m *Message) {
	gg.g.P("func (x *", m.GoIdent, ") ", m.GoIdent, structSuffix, "() (*", m.GoIdent, structSuffix, ", error) {")

	for _, field := range m.Fields {
		if gi, ok := m.changeGoTypes[field.GoName]; ok {
			gg.genPb2ModelMethodFiled(m, field, gi)
		}
	}

	gg.g.P("return &", m.GoIdent, structSuffix, "{")
	for _, field := range m.Fields {
		if _, ok := m.changeGoTypes[field.GoName]; !ok {
			gg.g.P(field.GoName, ": x.", field.GoName, ",")
		} else {
			gg.g.P(field.GoName, ": ", m.pb2ModelGoTypes[field.GoName], ",")
		}
	}
	gg.g.P("}, nil")
	gg.g.P("}")
	gg.g.P()
}

func (gg *GormGenerator) genPb2ModelMethodFiled(m *Message, field *protogen.Field, gi goIdent) {
	if v := proto.GetExtension(field.Desc.Options(), option.E_Rules); v != nil {
		rules, ok := v.(*option.Rules)
		if ok && rules.GetType() != nil {
			if rules.GetType() != nil {
				switch r := rules.Type.(type) {
				case *option.Rules_Time:
					if t := r.Time.Type; t != nil {
						if gi.oldGoType == timestampImportGoIndentPointer {
							if gi.newGoType == gg.g.QualifiedGoIdent(timePackage.Ident("Time")) {
								gg.g.P(firstLower(field.GoName), ", err := ", ptypesPackage.Ident("Timestamp"), "(x.", field.GoName, ")")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P()
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(dateTypesPackage.Ident("Date")) {
								gg.g.P(firstLower(field.GoName), "Time, err := ", ptypesPackage.Ident("Timestamp"), "(x.", field.GoName, ")")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P(firstLower(field.GoName), " := ", dateTypesPackage.Ident("Date"), "(", firstLower(field.GoName), "Time)")
								gg.g.P()
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(gormPackage.Ident("DeletedAt")) {
								gg.g.P(firstLower(field.GoName), "Time, err := ", ptypesPackage.Ident("Timestamp"), "(x.", field.GoName, ")")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P(firstLower(field.GoName), " := ", gormPackage.Ident("DeletedAt"), "{ Time: ", firstLower(field.GoName), "Time}")
								gg.g.P()
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
						}
						if gi.oldGoType == "int64" || gi.oldGoType == "uint64" {
							if gi.newGoType == gg.g.QualifiedGoIdent(timePackage.Ident("Time")) {
								suffix := ""
								switch r.Time.GetTimeUnit() {
								case option.TimeUnit_ms:
									suffix += "time.UnixMilli(int64(x." + field.GoName + "))"
								case option.TimeUnit_us:
									suffix += "time.UnixMicro(int64(x." + field.GoName + "))"
								case option.TimeUnit_ns:
									suffix += "time.Unix(0, int64(x." + field.GoName + "))"
								default:
									suffix += "time.Unix(int64(x." + field.GoName + "), 0)"
								}
								gg.g.P(firstLower(field.GoName), " := ", suffix)
								gg.g.P()
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(dateTypesPackage.Ident("Date")) {
								suffix := ""
								switch r.Time.GetTimeUnit() {
								case option.TimeUnit_ms:
									suffix += "time.UnixMilli(int64(x." + field.GoName + "))"
								case option.TimeUnit_us:
									suffix += "time.UnixMicro(int64(x." + field.GoName + "))"
								case option.TimeUnit_ns:
									suffix += "time.Unix(0, int64(x." + field.GoName + "))"
								default:
									suffix += "time.Unix(int64(x." + field.GoName + "), 0)"
								}
								gg.g.P(firstLower(field.GoName), " := ", dateTypesPackage.Ident("Date"), "(", suffix, ")")
								gg.g.P()
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(gormPackage.Ident("DeletedAt")) {
								suffix := ""
								switch r.Time.GetTimeUnit() {
								case option.TimeUnit_ms:
									suffix += "time.UnixMilli(int64(x." + field.GoName + "))"
								case option.TimeUnit_us:
									suffix += "time.UnixMicro(int64(x." + field.GoName + "))"
								case option.TimeUnit_ns:
									suffix += "time.Unix(0, int64(x." + field.GoName + "))"
								default:
									suffix += "time.Unix(int64(x." + field.GoName + "), 0)"
								}
								gg.g.P(firstLower(field.GoName), " := ", gormPackage.Ident("DeletedAt"), "{ Time: ", suffix)
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
						}
						if gi.oldGoType == "string" {
							if gi.newGoType == gg.g.QualifiedGoIdent(timePackage.Ident("Time")) {
								gg.g.P(firstLower(field.GoName), ", err := ", timePackage.Ident("Parse"), "(\"2006-01-02 15:04:05\", x.", field.GoName, ")")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P()
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(dateTypesPackage.Ident("Date")) {
								gg.g.P(firstLower(field.GoName), "err := ", timePackage.Ident("Parse"), "(\"2006-01-02 15:04:05\", ", dateTypesPackage.Ident("Date"), "(x.", field.GoName, "))")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P()
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(gormPackage.Ident("DeletedAt")) {
								gg.g.P("t", ", err := ", timePackage.Ident("Parse"), "(\"2006-01-02 15:04:05\", x.", field.GoName, ")")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P()
								gg.g.P(firstLower(field.GoName), " := ", gormPackage.Ident("DeletedAt"), "{ Time: t}")
								m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
							}
						}
					}
				case *option.Rules_Enum:
					if t := r.Enum.Type; t != nil {
						if gi.newGoType == "string" {
							gg.g.P(firstLower(field.GoName), " := x.", field.GoName, ".String()")
						} else {
							gg.g.P(firstLower(field.GoName), " := x.", field.GoName)
						}
						gg.g.P()
						m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
					}
				}
			}
		}
		if !field.Desc.IsMap() {
			switch field.Desc.Kind() {
			case protoreflect.MessageKind, protoreflect.GroupKind:
				if _, ok := specialMessageKinds[gi.oldGoType]; !ok {
					gg.g.P(firstLower(field.GoName), ", err := x.", field.GoName, ".", field.GoIdent, structSuffix, "()")
					gg.g.P("if err != nil {")
					gg.g.P("return nil, err")
					gg.g.P("}")
					gg.g.P()
					m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
				}
			}
		}

		if field.Desc.IsList() {
			gg.g.P(firstLower(field.GoName), " := ", gi.newGoType, "(x.", field.GoName, ")")
			gg.g.P()
			m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
		}

		if field.Desc.IsMap() {
			gg.g.P(firstLower(field.GoName), " := ", gi.newGoType, "(x.", field.GoName, ")")
			gg.g.P()
			m.pb2ModelGoTypes[field.GoName] = firstLower(field.GoName)
		}
	}
}

func (gg *GormGenerator) genModel2PbMethodFiled(m *Message, field *protogen.Field, gi goIdent) {
	if v := proto.GetExtension(field.Desc.Options(), option.E_Rules); v != nil {
		rules, ok := v.(*option.Rules)
		if ok && rules.GetType() != nil {
			if rules.GetType() != nil {
				switch r := rules.Type.(type) {
				case *option.Rules_Time:
					if t := r.Time.Type; t != nil {
						if gi.oldGoType == timestampImportGoIndentPointer {
							if gi.newGoType == gg.g.QualifiedGoIdent(timePackage.Ident("Time")) {
								gg.g.P(firstLower(field.GoName), ", err := ", ptypesPackage.Ident("TimestampProto"), "(x.", field.GoName, ")")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(dateTypesPackage.Ident("Date")) {
								gg.g.P(firstLower(field.GoName), ", err := ", ptypesPackage.Ident("TimestampProto("), timePackage.Ident("Time"), "(x.", field.GoName, "))")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(gormPackage.Ident("DeletedAt")) {
								gg.g.P(firstLower(field.GoName), ", err := ", ptypesPackage.Ident("TimestampProto("), timePackage.Ident("Time"), "(x.", field.GoName, ".Time))")
								gg.g.P("if err != nil {")
								gg.g.P("return nil, err")
								gg.g.P("}")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
						}
						if gi.oldGoType == "int64" || gi.oldGoType == "uint64" {
							if gi.newGoType == gg.g.QualifiedGoIdent(timePackage.Ident("Time")) {
								suffix := "x." + field.GoName
								switch r.Time.GetTimeUnit() {
								case option.TimeUnit_ms:
									suffix += ".UnixMilli()"
								case option.TimeUnit_us:
									suffix += ".UnixMicro()"
								case option.TimeUnit_ns:
									suffix += ".UnixNano()"
								default:
									suffix += ".Unix()"
								}
								gg.g.P(firstLower(field.GoName), " := ", gi.oldGoType, "(", suffix, ")")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(dateTypesPackage.Ident("Date")) {
								suffix := "time.Time(x." + field.GoName + ")"
								switch r.Time.GetTimeUnit() {
								case option.TimeUnit_ms:
									suffix += ".UnixMilli()"
								case option.TimeUnit_us:
									suffix += ".UnixMicro()"
								case option.TimeUnit_ns:
									suffix += ".UnixNano()"
								default:
									suffix += ".Unix()"
								}
								gg.g.P(firstLower(field.GoName), " := ", gi.oldGoType, "(", suffix, ")")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(gormPackage.Ident("DeletedAt")) {
								suffix := "time.Time(x." + field.GoName + ".Time))."
								switch r.Time.GetTimeUnit() {
								case option.TimeUnit_ms:
									suffix += "UnixMilli()"
								case option.TimeUnit_us:
									suffix += "UnixMicro()"
								case option.TimeUnit_ns:
									suffix += "UnixNano()"
								default:
									suffix += "Unix()"
								}
								gg.g.P(firstLower(field.GoName), " := ", gi.oldGoType, "(", suffix, ")")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
						}
						if gi.oldGoType == "string" {
							if gi.newGoType == gg.g.QualifiedGoIdent(timePackage.Ident("Time")) {
								gg.g.P(firstLower(field.GoName), " := x.", field.GoName, ".Format(\"2006-01-02 15:04:05\")")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(dateTypesPackage.Ident("Date")) {
								gg.g.P(firstLower(field.GoName), " := ", timePackage.Ident("Time"), "(x.", field.GoName, ").Format(\"2006-01-02 15:04:05\")")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
							if gi.newGoType == gg.g.QualifiedGoIdent(gormPackage.Ident("DeletedAt")) {
								gg.g.P(firstLower(field.GoName), " := x.", field.GoName, ".Time.Format(\"2006-01-02 15:04:05\")")
								gg.g.P()
								m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
							}
						}
					}
				case *option.Rules_Enum:
					if t := r.Enum.Type; t != nil {
						if gi.newGoType == "string" {
							gg.g.P(firstLower(field.GoName), " := ", field.Enum.GoIdent, "(", field.Enum.GoIdent, "_value[", "x.", field.GoName, "])")
						} else {
							gg.g.P(firstLower(field.GoName), " := x.", field.GoName)
						}
						gg.g.P()
						m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
					}
				}
			}
		}

		if !field.Desc.IsMap() {
			switch field.Desc.Kind() {
			case protoreflect.MessageKind, protoreflect.GroupKind:
				if _, ok := specialMessageKinds[gi.oldGoType]; !ok {
					gg.g.P(firstLower(field.GoName), ", err := x.", field.GoName, ".", field.GoIdent, "()")
					gg.g.P("if err != nil {")
					gg.g.P("return nil, err")
					gg.g.P("}")
					gg.g.P()
					m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
				}
			}
		}

		if field.Desc.IsList() {
			gg.g.P(firstLower(field.GoName), " := ", gi.oldGoType, "(x.", field.GoName, ")")
			gg.g.P()
			m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
		}

		if field.Desc.IsMap() {
			gg.g.P(firstLower(field.GoName), " := ", gi.oldGoType, "(x.", field.GoName, ")")
			gg.g.P()
			m.model2PbGoTypes[field.GoName] = firstLower(field.GoName)
		}
	}
}

func (gg *GormGenerator) genModel2PbMethod(m *Message) {
	gg.g.P("func (x *", m.GoIdent, structSuffix, ") ", m.GoIdent, "() (*", m.GoIdent, ", error) {")
	for _, field := range m.Fields {
		if gi, ok := m.changeGoTypes[field.GoName]; ok {
			gg.genModel2PbMethodFiled(m, field, gi)
		}
	}
	gg.g.P("return &", m.GoIdent, "{")
	for _, field := range m.Fields {
		if _, ok := m.changeGoTypes[field.GoName]; !ok {
			gg.g.P(field.GoName, ": x.", field.GoName, ",")
		} else {
			gg.g.P(field.GoName, ": ", m.model2PbGoTypes[field.GoName], ",")
		}
	}
	gg.g.P("}, nil")
	gg.g.P("}")
	gg.g.P()
}

func (gg *GormGenerator) genIndexOptionFunction(m *Message) {
	for _, field := range m.Fields {
		if v := proto.GetExtension(field.Desc.Options(), option.E_Rules); v != nil {
			rules, ok := v.(*option.Rules)
			if ok && rules.GetIdx() != nil {
				gg.genIndexFunction(m, field)
			}
		}
	}
}

func (gg *GormGenerator) genNewType(m *Message) {
	var has bool
	for _, gi := range m.changeGoTypes {
		if gi.needNew {
			has = true
			gg.genNewTypeField(m, gi)
		}
	}

	if has {
		gg.g.P("// Value for valuer helper")
		gg.g.P("func Value(data any) (any, error) {")
		gg.g.P("v := ", reflectPackage.Ident("ValueOf"), "(data)")
		gg.g.P("if v.IsZero() {")
		gg.g.P("return nil, nil")
		gg.g.P("}")
		gg.g.P("return ", jsonPackage.Ident("Marshal"), "(data)")
		gg.g.P("}")
		gg.g.P()
		gg.g.P("// Scan for scanner helper")
		gg.g.P("func Scan(data any, value any) error {")
		gg.g.P("if value == nil {")
		gg.g.P("return nil")
		gg.g.P("}")
		gg.g.P("switch v := value.(type) {")
		gg.g.P("case []byte:")
		gg.g.P("return ", jsonPackage.Ident("Unmarshal"), "(v, data)")
		gg.g.P("case string:")
		gg.g.P("return ", jsonPackage.Ident("Unmarshal"), "([]byte(v), data)")
		gg.g.P("default:")
		gg.g.P("return ", fmtPackage.Ident("Errorf"), "(\"unsupported Scan, storing driver.Value type %T into Go value type %T\", v, data)")
		gg.g.P("}")
		gg.g.P("}")
		gg.g.P()
	}
}

func (gg *GormGenerator) genNewTypeField(m *Message, gi goIdent) {
	gg.g.P("type ", gi.newGoType, " ", gi.oldGoType)
	gg.g.P()
	gg.g.P("func (x ", gi.newGoType, ") Value() (", driverPackage.Ident("Value"), ", error) {")
	gg.g.P("return Value(x)")
	gg.g.P("}")
	gg.g.P()
	gg.g.P("func (x *", gi.newGoType, ") Scan(value any) error {")
	gg.g.P("return Scan(x, value)")
	gg.g.P("}")
	gg.g.P()
}

func (gg *GormGenerator) genIndexFunction(m *Message, field *protogen.Field) {
	goType, pointer := gg.fieldGoType(field)
	if pointer {
		goType = "*" + goType
	}
	goType = gg.changeGoType(m, field, goType)
	gg.g.P("func ", m.GoIdent, structSuffix, field.GoName, "(x ", goType, ") ", mysqlxPackage.Ident("Option"), " {")
	gg.g.P("return func(db *", gormPackage.Ident("DB"), ") *", gormPackage.Ident("DB"), " {")
	gg.g.P("return db.Where(\"", camelToSnake(field.GoName), "= ?\", x)")
	gg.g.P("}")
	gg.g.P("}")
	gg.g.P()
}

func (gg *GormGenerator) genMaybeIgnoreGoTypes() {
	for goType := range gg.maybeIgnoreGoTypes {
		gg.g.P("var _ ", goType)
	}
}

func (gg *GormGenerator) protocVersion() string {
	v := gg.gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// fieldGoType returns the Go type used for a field.
//
// If it returns pointer=true, the struct field is a pointer to the type.
func (gg *GormGenerator) fieldGoType(field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = gg.g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind, protoreflect.GroupKind:
		goType = "*" + gg.g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := gg.fieldGoType(field.Message.Fields[0])
		valType, _ := gg.fieldGoType(field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}

func camelToSnake(s string) string {
	var result []rune
	for i, r := range s {
		if unicode.IsUpper(r) {
			// 如果不是第一个字符，前面加下划线
			if i > 0 {
				result = append(result, '_')
			}
			// 转换为小写
			result = append(result, unicode.ToLower(r))
		} else {
			result = append(result, r)
		}
	}
	return string(result)
}

func firstLower(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}
